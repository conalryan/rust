
Now we need to have a JavaScript project that uses our package. 
We can use npm to create an application based on the wasm-app template:
`npm init wasm-app hello-bindgen-app`

This step is unnecessary if you are using the Wasm package in an existing JavaScript application, 
but for our purposes this is the most expedient path. 
We modify the package.json file to make our Wasm package a dependency:
hello-bindgen/package.json
```json
"dependencies": { 
  "hello-bindgen": "file:../pkg"
},
```

Then we edit index.js to load our package and call the greet function:
hello-bindgen-app/index.js
```javascript
import * as wasm from "hello-bindgen"; 
let result = wasm.greet("Rust");
console.log(result);
```

We need to use npm to install the dependencies needed to package and serve our code:
`npm install`

Finally, we can use the bundled webpack dev server to view our code by running the start script that comes with the template we used:
`npm start`

Again we can navigate to http://localhost:8080 and look in the console to see: Hello,Rust!

What just happened?
--------------------------------------------------------------------------------
189

The `wasm-bindgen` crate generates some Rust code based on where you put the attribute. 
We annotated a function so the crate will generate a wrapper function that handles marshalling the complex data types,
`&str` and `String` in this case, into `integers` that Wasm can handle. 
Note that we did not say `extern "C"` on our greet function which is by design. 
As in our manual example, the actual greet function that is exposed ends up being a wrapper which calls into our original greet function which will get a mangled name.

You can put the `wasm_bindgen` attribute on `structs`, `impl blocks`, and a variety of other Rust items to expose them to JavaScript. 
The [wasm-bindgen docs](https://rustwasm.github.io/docs/wasm-bindgen/) are a great source for understanding what and how things are exposed and what options you have.

The next step is that wasm-pack uses the wasm-bindgen CLI to generate JavaScript wrapper code based 
on items annotated with the wasm_bindgen attribute. 
The JavaScript glue code requires you to run an extra step outside of the normal Rust build process. 
The internals of the code generated by wasm-bindgen on the Rust side means that you really want 
to use wasm-bindgen to generate the JavaScript wrappers for you as well.

The DOM and friends
--------------------------------------------------------------------------------
190
As part of the wasm-bindgen project, there is the [web_sys](https://rustwasm.github.io/wasm-bindgen/api/web_sys/) crate which exposes a large number of raw Web APIs. Manipulating the DOM is one thing that is possible using this crate.

Threads
--------------------------------------------------------------------------------
There is a [proposal](https://github.com/WebAssembly/threads) to add threads to WebAssembly. 
As part of this proposal there are also ideas about atomics and other concepts necessary to make shared linear memory across threads manageable. 
There is a good summary [blog post](https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html) by Alex Crichton on Oct 24, 2018 which breaks down a lot of the exciting details.

WebAssembly System Interface (WASI)
--------------------------------------------------------------------------------

WebAssembly derives its security features from only having access to what it is explicitly given. That is, Wasm can be compiled to machine code but it cannot do things like open arbitrary sockets unless the system explicitly passes an instance the capability to do so. Today this is done via the JavaScript APIs available to Wasm code running in the browser. But there is an effort to run Wasm outside of the browser.
Outside the browser there is a real system to deal with. This leads to the question of portability of Wasm code across different systems that might want to execute the code. It also begs the question about how to handle safely support system calls like open for opening a file.
Wasm is an assembly language for a logical machine which can therfore be implemented virtually on any number of platforms. The WebAssembly System Interface, or WASI, is an attempt to standardize the system calls that Wasm knows about so that different implementations can build to a spec and therefore abstract the underlying operating system from the assembly language. This is being designed with portability and security as the paramount concerns. It is still in early days but it is a very exciting proposition.e
